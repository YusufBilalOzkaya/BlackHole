import sys
import os
import math
import json
from PyQt5.QtWidgets import QApplication, QWidget, QLabel, QMenu, QColorDialog, QPushButton, QVBoxLayout, QStyle, QFileIconProvider, QFileDialog, QSlider, QHBoxLayout, QWidgetAction, QActionGroup, QDialog, QMessageBox
import shutil
from PyQt5.QtCore import Qt, QPropertyAnimation, QRect, pyqtProperty, QEasingCurve, QPoint, QTimer, QPointF, QSize, pyqtSignal, QRectF, QFileInfo, QStandardPaths
from PyQt5.QtGui import QPainter, QColor, QBrush, QPen, QIcon, QPixmap, QPainterPath, QImage, QCursor
import configparser
import random

try:
    from send2trash import send2trash
except ImportError:
    send2trash = None

try:
    import win32api
    import win32gui
    import win32con
    PYWIN32_AVAILABLE = True
    import vdf # Steam kütüphanesini okumak için
except ImportError:
    PYWIN32_AVAILABLE = False
    vdf = None

class ImageCropper(QDialog):
    # Kırpma tamamlandığında kırpılmış pixmap'i gönderen sinyal
    cropped = pyqtSignal(QPixmap)

    def __init__(self, pixmap, parent=None):
        super().__init__(parent)
        self.pixmap = pixmap
        self.setWindowFlags(Qt.Tool)
        self.setWindowTitle("Cildi Kırp")
        self.setFixedSize(800, 600) # Sabit bir pencere boyutu
        self.scaled_pixmap = self.pixmap.scaled(self.size(), Qt.KeepAspectRatio, Qt.SmoothTransformation)

        # Pencere boyutunu resme göre ayarla, ama çok büyük olmasın
        w, h = self.scaled_pixmap.width(), self.scaled_pixmap.height()
        
        # Başlangıç kırpma dörtgeni (ortada, kare şeklinde)
        side = min(w, h) * 0.8
        self.crop_rect = QRectF((w - side) / 2, (h - side) / 2, side, side)

        self.drag_pos = None
        self.dragging = False

        # "Tamam" butonu
        ok_button = QPushButton("Tamam")
        ok_button.clicked.connect(self.accept_crop)

        # Layout
        layout = QVBoxLayout()
        layout.addStretch() # Butonu aşağı it
        layout.addWidget(ok_button)
        self.setLayout(layout)

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)

        # Ölçeklenmiş resmi çiz
        rect = self.scaled_pixmap.rect()
        rect.moveCenter(self.rect().center())
        qp.drawPixmap(rect.topLeft(), self.scaled_pixmap)

        # Kırpma alanının dışını karart
        path = QPainterPath()
        path.addRect(QRectF(rect))
        path.addRect(self.crop_rect)
        qp.fillPath(path, QColor(0, 0, 0, 150))

        # Kırpma dörtgeninin kenarlarını çiz
        qp.setPen(QPen(Qt.white, 2, Qt.DashLine))
        qp.drawRect(self.crop_rect)
        qp.end()

    def mousePressEvent(self, event):
        if self.crop_rect.contains(event.pos()):
            self.dragging = True
            self.drag_pos = event.pos() - self.crop_rect.topLeft()

    def mouseMoveEvent(self, event):
        if self.dragging:
            new_top_left = event.pos() - self.drag_pos
            # Dörtgenin pencere sınırları içinde kalmasını sağla
            img_rect = self.scaled_pixmap.rect()
            img_rect.moveCenter(self.rect().center())
            new_top_left.setX(max(img_rect.left(), min(new_top_left.x(), img_rect.right() - self.crop_rect.width())))
            new_top_left.setY(max(img_rect.top(), min(new_top_left.y(), img_rect.bottom() - self.crop_rect.height())))
            self.crop_rect.moveTopLeft(new_top_left)
            self.update()

    def mouseReleaseEvent(self, event):
        self.dragging = False

    def accept_crop(self):
        # Kırpma işlemini onayla
        # Orijinal ve ölçeklenmiş resimler arasındaki ölçek faktörlerini hesapla
        scale_x = self.pixmap.width() / self.scaled_pixmap.width()
        scale_y = self.pixmap.height() / self.scaled_pixmap.height()

        # Ölçeklenmiş resmin pencere içinde ne kadar kaydırıldığını (offset) bul
        offset_x = (self.width() - self.scaled_pixmap.width()) / 2
        offset_y = (self.height() - self.scaled_pixmap.height()) / 2

        # Kırpma dörtgenini orijinal resmin koordinatlarına dönüştür
        source_rect = QRectF((self.crop_rect.x() - offset_x) * scale_x, (self.crop_rect.y() - offset_y) * scale_y, self.crop_rect.width() * scale_x, self.crop_rect.height() * scale_y)
        cropped_pixmap = self.pixmap.copy(source_rect.toRect())
        self.cropped.emit(cropped_pixmap)
        self.close()

    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Enter or event.key() == Qt.Key_Return:
            self.accept_crop()
        elif event.key() == Qt.Key_Escape:
            self.close()

def get_steam_libraries():
    """Steam kütüphane klasörlerini bulur."""
    if not PYWIN32_AVAILABLE or not vdf:
        return []
    try:
        # Steam'in kurulu olduğu ana dizini registry'den bul
        key = win32api.RegOpenKey(win32con.HKEY_CURRENT_USER, r"Software\Valve\Steam", 0, win32con.KEY_READ)
        steam_path = win32api.RegQueryValueEx(key, "SteamPath")[0]
        win32api.RegCloseKey(key)

        library_vdf_path = os.path.join(steam_path, 'steamapps', 'libraryfolders.vdf')
        if not os.path.exists(library_vdf_path):
            return [steam_path]

        with open(library_vdf_path, 'r') as f:
            data = vdf.load(f)

        libraries = [steam_path]
        # 'libraryfolders' anahtarı altındaki diğer kütüphaneleri ekle
        for key, value in data.get('libraryfolders', {}).items():
            if key.isdigit() and isinstance(value, dict) and 'path' in value:
                libraries.append(value['path'])
        return libraries
    except Exception:
        return []

def find_steam_game_exe(app_id):
    """Verilen AppID için Steam oyununun .exe dosyasını bulur."""
    libraries = get_steam_libraries()
    for library in libraries:
        manifest_path = os.path.join(library, 'steamapps', f'appmanifest_{app_id}.acf')
        if os.path.exists(manifest_path):
            try:
                with open(manifest_path, 'r') as f:
                    data = vdf.load(f)
                install_dir = data.get('AppState', {}).get('installdir')
                executable = data.get('AppState', {}).get('launch', {}).get('0', {}).get('executable')
                if install_dir and executable:
                    exe_path = os.path.join(library, 'steamapps', 'common', install_dir, executable)
                    if os.path.exists(exe_path):
                        return exe_path
            except Exception:
                continue
    return None

def find_epic_game_exe(url_target):
    """Epic Games URL'sinden oyunun .exe dosyasını bulmaya çalışır."""
    if not PYWIN32_AVAILABLE:
        return None
    try:
        # Epic Games'in metadata klasörünü bul
        program_data = os.environ.get('PROGRAMDATA', 'C:\\ProgramData')
        metadata_dir = os.path.join(program_data, 'Epic', 'EpicGamesLauncher', 'Data', 'Manifests')

        if not os.path.isdir(metadata_dir):
            return None

        # URL'den oyun adını çıkar: com.epicgames.launcher://apps/AppName?action=launch&silent=true -> AppName
        app_name = url_target.split('/apps/')[1].split('?')[0]

        for item in os.listdir(metadata_dir):
            if item.endswith('.item'):
                manifest_path = os.path.join(metadata_dir, item)
                with open(manifest_path, 'r', encoding='utf-8') as f:
                    manifest_data = json.load(f)
                
                # Manifest'teki AppName ile URL'deki AppName eşleşiyor mu?
                if manifest_data.get('AppName') == app_name:
                    install_location = manifest_data.get('InstallLocation')
                    launch_executable = manifest_data.get('LaunchExecutable')
                    if install_location and launch_executable:
                        # Bazen yol \ ile değil / ile ayrılmış olabilir
                        exe_path = os.path.join(install_location, *launch_executable.replace('/', '\\').split('\\'))
                        if os.path.exists(exe_path):
                            return exe_path
    except Exception:
        return None
    return None

def extract_icon_from_exe(exe_path, cache_dir, cache_key):
    """.exe dosyasından ikonu çıkarır ve önbelleğe alır."""
    if not exe_path or not PYWIN32_AVAILABLE:
        return None
    
    cache_path = os.path.join(cache_dir, f"{cache_key}.png")
    if os.path.exists(cache_path):
        return QIcon(cache_path)

    try:
        large, small = win32gui.ExtractIconEx(exe_path, 0, 1)
        if large:
            hicon = large[0]
            # İkonu QPixmap'e dönüştür ve PNG olarak kaydet
            pixmap = QPixmap.fromImage(QImage.fromHICON(hicon))
            if not pixmap.isNull():
                os.makedirs(cache_dir, exist_ok=True)
                pixmap.save(cache_path, "PNG")
                # Kaynakları serbest bırak
                for ico in large: win32gui.DestroyIcon(ico)
                for ico in small: win32gui.DestroyIcon(ico)
                return QIcon(cache_path)
    except Exception as e:
        # print(f"Ikon çıkarılamadı ({exe_path}): {e}")
        pass
    return None


def get_icon_for_url_shortcut(path):
    """
    .url kısayol dosyaları için Windows API kullanarak ikonu alır.
    """
    if not PYWIN32_AVAILABLE:
        return QIcon()

    # Önbellek için dosya adından bir anahtar oluştur
    cache_key = os.path.splitext(os.path.basename(path))[0]
    cache_dir = os.path.join(os.path.expanduser("~"), ".blackhole_launcher_cache")
    # .url dosyalarını okumak için configparser kullan
    config = configparser.ConfigParser()
    try:
        config.read(path)
        url = config.get('InternetShortcut', 'URL', fallback='')
        icon_file = config.get('InternetShortcut', 'IconFile', fallback=None)
        icon_index_str = config.get('InternetShortcut', 'IconIndex', fallback='0')
        icon_index = int(icon_index_str)
    except Exception:
        return QIcon(QApplication.style().standardIcon(QStyle.SP_FileLinkIcon))
    
    # Eğer IconFile belirtilmişse, doğrudan onu kullan
    if icon_file:
        try:
            expanded_path = os.path.expandvars(icon_file)
            absolute_path = os.path.abspath(expanded_path)
            icon = extract_icon_from_exe(absolute_path, cache_dir, cache_key)
            if icon:
                return icon
        except Exception:
            pass

    # Steam oyunları için (steam://rungameid/...)
    if url.startswith("steam://"):
        try:
            app_id = url.split('/')[-1]
            exe_path = find_steam_game_exe(app_id)
            icon = extract_icon_from_exe(exe_path, cache_dir, cache_key)
            if icon:
                return icon
        except Exception:
            pass

    # Epic Games oyunları için (com.epicgames.launcher://...)
    if url.startswith("com.epicgames.launcher://"):
        try:
            exe_path = find_epic_game_exe(url)
            icon = extract_icon_from_exe(exe_path, cache_dir, cache_key)
            if icon:
                return icon
        except Exception:
            pass

    # Fallback: Eğer hiçbir şey bulunamazsa, genel bir web ikonu kullan
    try:
        return QIcon(QApplication.style().standardIcon(QStyle.SP_FileLinkIcon))
    except:
        return QIcon()

class BlackHoleWidget(QWidget):
    def __init__(self):
        super().__init__()

        # --- Pencere Ayarları ---
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool)
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.setAcceptDrops(True)
        self.setMouseTracking(True)  # Fare hareketlerini her zaman izle

        # --- Depolama ---
        self.storage_path = os.path.join(os.path.expanduser("~"), ".blackhole_storage")
        os.makedirs(self.storage_path, exist_ok=True)

        # --- Geometri ve Konum ---
        self.base_radius = 60 # Kara deliğin temel (kapalı) yarıçapı
        self._radius = self.base_radius

        # --- Durum Değişkenleri ---
        self.expanded = False
        self.files = []
        self.icon_radius = 28
        self.icon_positions = []
        self.hovered_icon = -1
        self.drag_pos = None
        self.settings_icon_rect = QRect()
        self.drag_started = False # Sürüklemenin başlayıp başlamadığını kontrol eden bayrak
        self.dragging_icon = -1 # Sürüklenen ikonun indeksi
        self.drag_icon_pixmap = None # Sürüklenen ikonun görseli
        self.drag_icon_pixmap_normal = None # Sürüklenen ikonun normal hali
        self.drag_icon_pixmap_delete = None # Sürüklenen ikonun silme (kırmızı) hali
        self.hovered_settings = False
        self.skin_path = None # Cilt dosyasının yolunu saklamak için
        self.hovered_icon_on_press = -1 # Tıklama anında hangi ikonun üzerinde olunduğunu tutar
        self.menu_is_open = False # Ayarlar menüsünün açık olup olmadığını kontrol eder
        self.active_menu = None # O an açık olan menünün referansı
        self.settings_menu = None # Ayarlar menüsünü önbelleğe almak için

        self.mode = "storage" # "storage" veya "destroyer"
        # Sürüklenen ikonu göstermek için hayalet widget
        self.ghost_icon_widget = QLabel()
        self.ghost_icon_widget.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowStaysOnTopHint | Qt.Tool | Qt.WA_TranslucentBackground)
        self.ghost_icon_widget.setAttribute(Qt.WA_TranslucentBackground)
        self.ghost_icon_widget.hide()

        # --- Renk Ayarları ---
        self.storage_color = QColor(20, 20, 30, 240)
        self.destroyer_color = QColor(150, 20, 30, 240)
        self.cropper = None # ImageCropper penceresi için referans
        self.skin_pixmap = None # Cilt için QPixmap

        # --- Animasyon Ayarları ---
        self.animation_type = "None"
        self.animation_timer = QTimer(self)
        self.animation_timer.timeout.connect(self.update_animations)
        self.orbit_angle = 0 # Yörünge animasyonu için
        self.pulsars = [] # Pulsar animasyonu için parçacıklar
        self.sparkles = []

        # --- Kapatma Zamanlayıcısı ---
        self.close_timer = QTimer(self)
        self.close_timer.setInterval(100) # 100 milisaniye gecikme
        self.close_timer.setSingleShot(True) # Sadece bir kez çalış
        self.close_timer.timeout.connect(self.collapse)

        # --- Bilgi Etiketi ---
        self.info = QLabel('Dosyaları buraya sürükle', self)
        self.info.setAlignment(Qt.AlignCenter)
        self.info.setStyleSheet("color: white; background-color: rgba(0,0,0,150); border-radius: 5px; padding: 5px;")
        self.info.adjustSize()
        self.info.hide()
        
        # Ayarları yükle
        self.load_settings()
        
        # Ayarlar menüsünü bir kere oluştur
        self.create_settings_menu()

    @pyqtProperty(float)
    def radius(self):
        return self._radius

    @radius.setter
    def radius(self, value):
        self._radius = value
        self.update()

    def paintEvent(self, event):
        qp = QPainter(self)
        qp.setRenderHint(QPainter.Antialiasing)
        qp.setPen(Qt.NoPen)

        center = self.rect().center()

        # Cilt (skin) veya düz renk çizimi
        if self.skin_pixmap:
            # Dairesel bir kırpma yolu oluştur
            path = QPainterPath()
            path.addEllipse(center, int(self.radius), int(self.radius))
            qp.setClipPath(path)

            # Resmi dairenin içine sığacak şekilde çiz
            target_rect = QRect(center.x() - int(self.radius), center.y() - int(self.radius), int(self.radius) * 2, int(self.radius) * 2)
            qp.drawPixmap(target_rect, self.skin_pixmap)
            qp.setClipping(False) # Kırpmayı sıfırla
        else:
            # Mod'a göre renk belirle
            if self.mode == "destroyer":
                # Yok edici modda kendi rengini kullan
                current_color = self.destroyer_color if not self.expanded else self.destroyer_color.lighter(120)
            else:
                # Depolama modunda kendi rengini kullan
                current_color = self.storage_color
            qp.setBrush(QBrush(current_color))
            qp.drawEllipse(center, int(self.radius), int(self.radius))

        # Pulsar animasyonu (Girdap)
        if self.animation_type == "Pulsar" and self.expanded: # Sadece genişlemişse çiz
            for pulsar in self.pulsars:
                # Ana rengin daha açık ve parlak bir tonunu kullan
                if self.mode == "destroyer":
                    pulsar_color = QColor(255, 100, 100, int(pulsar['alpha']))
                else:
                    pulsar_color = self.storage_color.lighter(150)
                pulsar_color.setAlpha(int(pulsar['alpha']))
                qp.setBrush(pulsar_color)
                qp.drawEllipse(QPointF(pulsar['x'], pulsar['y']), pulsar['size'], pulsar['size'])

        # Işıldama animasyonu
        if self.animation_type == "Işıldama" and self.expanded: # Sadece genişlemişse çiz
            for sparkle in self.sparkles:
                # Her ışıltının kendi parlaklık ve boyutunu kullan
                brush_color = QColor(255, 255, 220, int(sparkle['alpha']))
                qp.setBrush(brush_color)
                qp.drawEllipse(QPointF(sparkle['x'], sparkle['y']), sparkle['size'], sparkle['size'])

        self.icon_positions.clear()
        if self.expanded and self.files:
            n = len(self.files)
            # İkonları, büyüyen kara deliğin İÇİNDE bir yörüngeye yerleştir.
            # self.radius - 50 -> Büyüyen dairenin kenarından 50 piksel içeride bir yörünge.
            icon_orbit_radius = max(0, self.radius - 50)
            for i, path_info in enumerate(self.files):
                # Yörünge animasyonu için açıyı ayarla
                current_path, original_path, _ = path_info  # original_pos'u burada kullanmıyoruz, _ ile atlıyoruz
                angle = (2 * math.pi * i / n) + self.orbit_angle
                x = center.x() + int(icon_orbit_radius * math.cos(angle))
                y = center.y() + int(icon_orbit_radius * math.sin(angle))
                self.icon_positions.append(QPoint(x, y))

                brush_color = QColor(255, 200, 100, 240) if i == self.hovered_icon else QColor(200, 200, 255, 220)
                
                # İkonları çiz
                if current_path.lower().endswith('.url'):
                    # URL kısayolları için özel ikon alıcı
                    icon = get_icon_for_url_shortcut(current_path)
                elif os.path.isdir(current_path):
                    # Klasörler için standart klasör ikonunu kullan
                    icon = QApplication.style().standardIcon(QStyle.SP_DirIcon)
                else:
                    # Dosyanın gerçek ikonunu almak için QFileIconProvider kullan
                    from PyQt5.QtWidgets import QFileIconProvider
                    provider = QFileIconProvider()
                    icon = provider.icon(QFileInfo(current_path))

                pixmap = icon.pixmap(self.icon_radius * 2, self.icon_radius * 2)
                icon_rect = QRect(x - self.icon_radius, y - self.icon_radius, self.icon_radius * 2, self.icon_radius * 2)
                
                qp.setBrush(QBrush(brush_color)) # Arka plan rengi
                qp.drawEllipse(icon_rect)
                qp.drawPixmap(icon_rect, pixmap)

                if i == self.hovered_icon:
                    qp.setPen(QPen(QColor(255, 255, 255), 2))
                    qp.drawEllipse(icon_rect)
                    qp.setPen(Qt.NoPen) # Kalemi sıfırla

                # İkonun altına dosya adını yaz
                font = qp.font()
                font.setPointSize(8)
                qp.setFont(font)
                qp.setPen(QPen(QColor(255, 255, 255))) # Yazı rengi
                base_name = os.path.basename(original_path) # Orijinal adı göster
                file_name, _ = os.path.splitext(base_name)
                # Metni ikonun biraz altına çizmek için yeni bir dörtgen oluştur
                text_rect = icon_rect.translated(0, self.icon_radius + 2)
                qp.drawText(text_rect, Qt.AlignCenter | Qt.AlignTop, file_name)

        # Genişlemişse ayarlar simgesini çiz
        if self.expanded:
            # Ayarlar simgesini tam ortaya yerleştir
            icon_size = 30
            self.settings_icon_rect = QRect(center.x() - icon_size // 2, center.y() - icon_size // 2, icon_size, icon_size)
            
            settings_icon = self.style().standardIcon(getattr(self.style(), 'SP_BrowserReload')) # Dişli ikonu için alternatif
            
            # Üzerindeyse vurgula
            if self.hovered_settings:
                qp.setBrush(QColor(255,255,255, 50))
                qp.drawEllipse(self.settings_icon_rect)

            settings_icon.paint(qp, self.settings_icon_rect)



    def mouseMoveEvent(self, event):
        if event.buttons() == Qt.LeftButton and self.drag_pos:
            # Eğer sürükleme henüz başlamadıysa ve fare belli bir mesafeden fazla hareket ettiyse, sürüklemeyi başlat
            if not self.drag_started and (event.pos() - self.drag_pos).manhattanLength() > 5:
                self.drag_started = True
                # Tıklama anında bir ikonun üzerindeysek, ikon sürüklemeyi başlat
                if self.hovered_icon != -1:
                    self.dragging_icon = self.hovered_icon_on_press
                    path, _, _ = self.files[self.dragging_icon]
                    if os.path.isdir(path):
                        # Sürüklenen bir klasörse, standart klasör ikonunu kullan
                        icon = QApplication.style().standardIcon(QStyle.SP_DirIcon)
                    elif path.lower().endswith('.url'):
                        # URL kısayoluysa, özel fonksiyonu kullan
                        icon = get_icon_for_url_shortcut(path)
                    else:
                        provider = QFileIconProvider()
                        icon = provider.icon(QFileInfo(path))
                    
                    # Normal ve silme görsellerini sürükleme başında bir kez oluştur
                    base_pixmap = icon.pixmap(self.icon_radius * 4, self.icon_radius * 4) # Yüksek çözünürlüklü alalım
                    self.drag_icon_pixmap_normal = base_pixmap.scaled(self.icon_radius * 2, self.icon_radius * 2, Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    
                    temp_pixmap = base_pixmap.copy()
                    painter = QPainter(temp_pixmap)
                    painter.setCompositionMode(QPainter.CompositionMode_SourceIn)
                    painter.fillRect(temp_pixmap.rect(), QColor(255, 100, 100, 180))
                    painter.end()
                    self.drag_icon_pixmap_delete = temp_pixmap.scaled(self.icon_radius * 2, self.icon_radius * 2, Qt.KeepAspectRatio, Qt.SmoothTransformation)

                    self.ghost_icon_widget.setPixmap(self.drag_icon_pixmap_normal)
                    self.ghost_icon_widget.setFixedSize(self.icon_radius * 2, self.icon_radius * 2)
                    self.ghost_icon_widget.show()

            # Sürükleme başladıysa, neyin sürüklendiğini kontrol et
            if self.drag_started:
                if self.dragging_icon != -1:
                    # Hayalet ikonu fare pozisyonuna taşı
                    pos = self.mapToGlobal(event.pos())
                    self.ghost_icon_widget.move(pos.x() - self.icon_radius, pos.y() - self.icon_radius)
                    
                    # Silme bölgesindeyse kırmızı yap
                    distance_from_center = math.sqrt((self.mapFromGlobal(QCursor.pos()).x() - self.rect().center().x())**2 + (self.mapFromGlobal(QCursor.pos()).y() - self.rect().center().y())**2)
                    # Yeniden çizim yapmak yerine önceden oluşturulmuş pixmap'ler arasında geçiş yap
                    current_pixmap = self.drag_icon_pixmap_delete if distance_from_center > self.radius else self.drag_icon_pixmap_normal
                    self.ghost_icon_widget.setPixmap(current_pixmap)
                    self.update()
                else:
                    # İkon sürüklenmiyor, pencereyi sürükle
                    self.move(event.globalPos() - self.drag_pos)
                return # Olayı burada bitir

        # Eğer bir ikon sürükleniyorsa, hover kontrolünü atla
        if self.dragging_icon != -1:
            return

        pos = event.pos()
        # Sürükleme yoksa, sadece hover durumunu kontrol et
        was_hovered = self.hovered_icon
        was_hovered_settings = self.hovered_settings

        # Ayarlar simgesi üzerinde mi kontrol et
        self.hovered_settings = self.expanded and self.settings_icon_rect.contains(pos)
        self.hovered_icon = -1
        if self.expanded:
            for i, icon_pos in enumerate(self.icon_positions):
                if (pos.x() - icon_pos.x())**2 + (pos.y() - icon_pos.y())**2 < self.icon_radius**2:
                    self.hovered_icon = i
                    break

        if was_hovered != self.hovered_icon or was_hovered_settings != self.hovered_settings:
            self.update()

    def enterEvent(self, event):
        # Eğer bir kapatma işlemi beklemedeyse, iptal et.
        self.close_timer.stop()
        self.expand()
        super().enterEvent(event)

    def leaveEvent(self, event):
        # Menüyü hemen kapatma, zamanlayıcıyı başlat.
        if self.expanded and not self.menu_is_open:
            self.close_timer.start()
        super().leaveEvent(event)

    def expand(self):
        if not self.expanded:
            self.expanded = True
            self.info.show()
            # Kara deliği, ikonları içine alacak kadar büyüt
            self.animate_radius(self.base_radius + 140)

    def collapse(self):
        if self.expanded:
            self.expanded = False
            self.hovered_icon = -1
            self.info.hide()
            self.animate_radius(self.base_radius)

    def animate_radius(self, target_radius):
        # Yok edici modda animasyon eğrisini daha agresif yap
        if self.mode == "destroyer":
            curve_type = QEasingCurve.OutBounce
            amplitude = 1.0
        else:
            curve_type = QEasingCurve.OutElastic
            amplitude = 1.2

        if hasattr(self, 'anim') and self.anim.state() == QPropertyAnimation.Running:
            if self.anim.endValue() != target_radius:
                self.anim.finished.connect(lambda: self.animate_radius(target_radius))
            return

        self.anim = QPropertyAnimation(self, b"radius")
        self.anim.setDuration(600)
        self.anim.setStartValue(self.radius)
        self.anim.setEndValue(target_radius)
        curve = QEasingCurve(QEasingCurve.OutElastic)
        curve.setAmplitude(1.2)
        self.anim.setEasingCurve(curve)
        self.anim.start()

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            # Depolama modunda dosya sınırı kontrolü yap
            if self.mode == "storage" and len(self.files) >= 11:
                event.ignore()
            else:
                event.acceptProposedAction()
        else:
            event.ignore()

    def dropEvent(self, event):
        urls = event.mimeData().urls()
        if not urls:
            return

        if self.mode == "storage":
            self.handle_storage_drop(urls)
        elif self.mode == "destroyer":
            self.handle_destroyer_drop(urls)

    def handle_destroyer_drop(self, urls):
        """Yok edici mod için bırakma olayını yönetir."""
        file_list_str = ""
        paths_to_delete = []
        for url in urls:
            if url.isLocalFile():
                path = url.toLocalFile()
                if sys.platform == 'win32' and path.startswith('/'):
                    path = path[1:]
                file_list_str += f"- {os.path.basename(path)}\n"
                paths_to_delete.append(path)

        if not paths_to_delete:
            return

        reply = QMessageBox.question(self, 'Kalıcı Silme Onayı',
            f"Aşağıdaki dosya/klasörleri **KALICI OLARAK** silmek istediğinize emin misiniz?\n\n"
            f"{file_list_str}\n"
            f"Bu işlem geri alınamaz!",
            QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.Yes:
            errors = []
            for path in paths_to_delete:
                try:
                    if os.path.isfile(path) or os.path.islink(path):
                        os.remove(path)
                    elif os.path.isdir(path):
                        shutil.rmtree(path)
                except Exception as e:
                    errors.append(f"'{os.path.basename(path)}': {e}")

            if errors:
                QMessageBox.critical(self, "Hata", "Bazı dosyalar silinirken hata oluştu:\n\n" + "\n".join(errors))
            else:
                QMessageBox.information(self, "Başarılı", "Seçilen tüm öğeler başarıyla silindi.")

    def handle_storage_drop(self, urls):
        """Depolama modu için bırakma olayını yönetir."""
        space_left = 11 - len(self.files)
        if space_left <= 0:
            return
        
        added_count = 0
        for url in urls:
            if url.isLocalFile() and added_count < space_left:
                # url.toLocalFile() bazen Windows'ta '/C:/Users/...' gibi hatalı bir yol verebilir.
                # Bu durumu düzeltmek için, yolun başındaki fazladan '/' karakterini kaldırıyoruz.
                original_path = url.toLocalFile()
                if sys.platform == 'win32' and original_path.startswith('/'):
                    original_path = original_path[1:]
                filename = os.path.basename(original_path)
                
                # Masaüstü ikon pozisyonunu al (eğer dosya masaüstündeyse)
                original_pos = None
                if PYWIN32_AVAILABLE and self.is_on_desktop(original_path):
                    original_pos = self.get_desktop_icon_pos(filename)

                new_path = os.path.join(self.storage_path, filename)
                
                # Eğer depolama klasöründe aynı isimde bir dosya/klasör zaten varsa,
                # çakışmayı önlemek için yeni dosyanın adını değiştir.
                counter = 1
                while os.path.exists(new_path):
                    name, ext = os.path.splitext(filename)
                    new_path = os.path.join(self.storage_path, f"{name}_{counter}{ext}")
                    counter += 1

                try:
                    # Mantığı basitleştiriyoruz:
                    # 1. Yukarıda 'new_path'in benzersiz olduğundan emin olduk.
                    # 2. Bu yüzden shutil.move(kaynak, hedef) her zaman çalışmalıdır.
                    # Bu komut, hem dosyaları hem de klasörleri güvenli bir şekilde taşır.
                    shutil.move(original_path, new_path)

                    # Eğer orijinal dosya/klasör hala yerindeyse, send2trash ile silmeyi dene.
                    if os.path.exists(original_path) and send2trash:
                        try:
                            send2trash(original_path)
                        except Exception as e_trash:
                            print(f"send2trash ile silinemedi: {original_path}, Hata: {e_trash}")

                    # Dosya bilgilerini (yeni yol, orijinal yol, orijinal pozisyon) olarak sakla
                    # moved_path, shutil.move'un döndürdüğü gerçek yeni yoldur.
                    final_path = new_path # Benzersiz isim garantisi sayesinde 'new_path' her zaman doğrudur.
                    self.files.append((final_path, original_path, original_pos))
                    added_count += 1
                except Exception as e:
                    # Hata oluştuğunda konsola yazdırmak, sorunu anlamamıza yardımcı olur.
                    print(f"Dosya taşınamadı: {original_path} -> {new_path}, Hata: {e}")
                    # Eğer taşıma başarısız olduysa ve hedefte kısmen bir şeyler oluştuysa temizle
                    if os.path.exists(new_path) and not os.path.exists(original_path):
                         shutil.move(new_path, original_path) # Geri taşı
        self.update()

    def is_on_desktop(self, path):
        """Bir dosyanın masaüstünde olup olmadığını kontrol eder."""
        desktop_path = QStandardPaths.writableLocation(QStandardPaths.DesktopLocation)
        return os.path.dirname(os.path.abspath(path)) == desktop_path

    def get_desktop_icon_pos(self, filename):
        """Masaüstündeki bir ikonun pozisyonunu alır."""
        try:
            hwnd = win32gui.FindWindow("Progman", "Program Manager")
            hwnd = win32gui.FindWindowEx(hwnd, 0, "SHELLDLL_DefView", None)
            hwnd = win32gui.FindWindowEx(hwnd, 0, "SysListView32", "FolderView")
            item_count = win32gui.SendMessage(hwnd, win32con.LVM_GETITEMCOUNT, 0, 0)
            for i in range(item_count):
                item_text = win32gui.SendMessage(hwnd, win32con.LVM_GETITEMTEXT, i, 0)
                if item_text == filename:
                    point = win32gui.SendMessage(hwnd, win32con.LVM_GETITEMPOSITION, i, 0)
                    return point
        except Exception as e:
            print(f"İkon pozisyonu alınamadı: {e}")
        return None

    def move_desktop_icon(self, path, pos):
        """Masaüstündeki bir ikonu belirtilen pozisyona taşır."""
        filename = os.path.basename(path)
        hwnd = win32gui.FindWindow("Progman", "Program Manager")
        hwnd = win32gui.FindWindowEx(hwnd, 0, "SHELLDLL_DefView", None)
        hwnd = win32gui.FindWindowEx(hwnd, 0, "SysListView32", "FolderView")
        # İkonun yeniden konumlandırılması için masaüstüne bir 'yenile' mesajı göndermek genellikle yeterlidir.
        # Gerçek taşıma işlemi için daha karmaşık API çağrıları gerekir, ancak bu genellikle işe yarar.
        win32gui.PostMessage(hwnd, win32con.WM_COMMAND, 41216, 0) # Refresh

    def mouseReleaseEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Eğer bir sürükleme işlemi başlamadıysa, bunu bir tıklama olarak kabul et
            if not self.drag_started:
                if self.hovered_icon != -1:
                    # Dosyayı depolama klasöründen aç (ilk eleman dosyanın şu anki yolu)
                    os.startfile(self.files[self.hovered_icon][0])
                    self.collapse()
                elif self.hovered_settings:
                    self.show_settings_menu(event.globalPos())
            # Eğer sürükleme işlemi bittiyse
            elif self.dragging_icon != -1:
                # Bırakma anındaki pozisyona göre hangi ikonun üzerinde olduğumuzu son bir kez kontrol et
                pos = event.pos()
                self.hovered_icon = -1
                for i, icon_pos in enumerate(self.icon_positions):
                    if (pos.x() - icon_pos.x())**2 + (pos.y() - icon_pos.y())**2 < self.icon_radius**2:
                        self.hovered_icon = i
                        break

                # Farenin merkezden uzaklığını hesapla
                distance_from_center = math.sqrt((pos.x() - self.rect().center().x())**2 + (pos.y() - self.rect().center().y())**2)

                # Eğer dairenin dışına bırakıldıysa, dosyayı orijinal konumuna geri taşı
                if distance_from_center > self.radius:
                    file_info = self.files.pop(self.dragging_icon)
                    current_path = file_info[0]
                    original_path = file_info[1]
                    try:
                        # Dosyayı orijinal konumuna geri taşı
                        # shutil.move hem dosyaları hem de klasörleri geri taşıyabilir.
                        if os.path.exists(original_path):
                             base, ext = os.path.splitext(original_path)
                             original_path = f"{base}_restored{ext}"
                        shutil.move(current_path, original_path)
                        # Eğer orijinal konum bilgisi varsa, dosyayı o konuma taşı
                        if len(file_info) > 2 and PYWIN32_AVAILABLE:
                            original_pos = file_info[2]
                            self.move_desktop_icon(original_path, original_pos)
                    except OSError as e:
                        print(f"Dosya orijinal konumuna geri taşınamadı: {current_path} -> {original_path}, Hata: {e}")
                    # Yörüngeyi yeniden hesapla
                    self.orbit_angle = 0 
                # Eğer başka bir ikonun üzerine bırakıldıysa, yer değiştir
                elif self.hovered_icon != -1 and self.hovered_icon != self.dragging_icon:
                    dragged_file = self.files.pop(self.dragging_icon)
                    self.files.insert(self.hovered_icon, dragged_file)
            # Sürükleme bittiğinde tüm durumları sıfırla
            self.drag_pos = None
            self.drag_started = False
            self.dragging_icon = -1
            self.drag_icon_pixmap = None
            self.drag_icon_pixmap_normal = None
            self.drag_icon_pixmap_delete = None
            self.ghost_icon_widget.hide()
            self.update()

    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            # Sürükleme işlemini başlatmak için başlangıç pozisyonunu kaydet
            # Pencere sürüklemesi için global pozisyonu, ikon sürüklemesi için yerel pozisyonu kullanacağız.
            self.drag_pos = event.globalPos() - self.frameGeometry().topLeft()
            self.hovered_icon_on_press = self.hovered_icon # Tıklama anında hangi ikonun üzerinde olduğumuzu kaydet
            self.drag_started = False # Henüz sürükleme başlamadı

    def closeEvent(self, event):
        # Uygulama kapanırken içindeki tüm dosyaları orijinal konumlarına geri taşı
        for file_info in self.files:
            current_path, original_path, original_pos = file_info
            try:
                # Eğer orijinal konumda aynı isimde bir dosya varsa, üzerine yazmayı önle
                if os.path.exists(original_path):
                    base, ext = os.path.splitext(original_path)
                    original_path = f"{base}_restored{ext}" # shutil.move bunu zaten yapabilir, ama garanti olsun.
                shutil.move(current_path, original_path)
                # Eğer orijinal konum bilgisi varsa, dosyayı o konuma taşı
                if len(file_info) > 2 and PYWIN32_AVAILABLE:
                    self.move_desktop_icon(original_path, original_pos)
            except OSError as e:
                print(f"Dosya kapatılırken geri yüklenemedi: {current_path} -> {original_path}, Hata: {e}")
        self.save_settings()
        super().closeEvent(event)

    def show_settings_menu(self, pos):
        # Menüyü her seferinde yeniden oluşturmak yerine önbelleğe alınmış olanı kullan
        if not self.settings_menu:
            self.create_settings_menu()

        # Animasyon menüsündeki işaretli durumu güncelle
        # Bu, ayarlar yüklendikten sonra veya program çalışırken yapılan
        # değişikliklerin menüde doğru görünmesini sağlar.
        for action in self.animation_menu.actions():
            action.setChecked(action.text() == self.animation_type)

        self.menu_is_open = True
        # exec_ metodu menü kapanana kadar bekler.
        # Karmaşık event filter'a gerek kalmaz.
        self.settings_menu.exec_(pos)
        self.menu_is_open = False
        
        # Menü kapandıktan sonra fare hala widget'ın dışındaysa, kapatma zamanlayıcısını başlat
        # Bu, dışarıya tıklandığında widget'ın açık kalmasını engeller.
        if not self.underMouse():
            self.close_timer.start()
            
    def create_settings_menu(self):
        """Ayarlar menüsünü bir kez oluşturur ve self.settings_menu'de saklar."""
        self.settings_menu = QMenu(self)
        self.settings_menu.setStyleSheet("""
            QMenu { background-color: #333; color: white; border: 1px solid #555; }
            QMenu::item:selected { background-color: #555; }
        """)
        
        # --- Büyüklük Ayarı için Slider ---
        size_widget = QWidget()
        size_layout = QHBoxLayout(size_widget)
        size_layout.setContentsMargins(10, 5, 10, 5)
        size_label = QLabel("Büyüklük:")
        size_slider = QSlider(Qt.Horizontal)
        size_slider.setRange(40, 100) # Min ve max yarıçap
        size_slider.setValue(self.base_radius)
        size_slider.valueChanged.connect(self.set_base_radius)
        size_layout.addWidget(size_label)
        size_layout.addWidget(size_slider)
        
        size_action = QWidgetAction(self.settings_menu)
        size_action.setDefaultWidget(size_widget)

        self.settings_menu.addSeparator()

        # --- Mod Seçimi ---
        mode_menu = self.settings_menu.addMenu("Mod")
        mode_group = QActionGroup(self)
        mode_group.setExclusive(True)

        storage_mode_action = mode_menu.addAction("Depolama Modu")
        storage_mode_action.setCheckable(True)
        storage_mode_action.setChecked(self.mode == "storage")
        storage_mode_action.triggered.connect(lambda: self.set_mode("storage"))
        mode_group.addAction(storage_mode_action)

        destroyer_mode_action = mode_menu.addAction("Yok Edici Mod")
        destroyer_mode_action.setCheckable(True)
        destroyer_mode_action.setChecked(self.mode == "destroyer")
        destroyer_mode_action.triggered.connect(lambda: self.set_mode("destroyer"))
        mode_group.addAction(destroyer_mode_action)

        self.settings_menu.addAction(size_action)
        
        self.settings_menu.addSeparator()
        
        color_action = self.settings_menu.addAction("Rengi Değiştir...")
        color_action.triggered.connect(self.open_color_picker)
        
        skin_menu = self.settings_menu.addMenu("Cilt")
        load_skin_action = skin_menu.addAction("Cilt Yükle...")
        load_skin_action.triggered.connect(self.load_skin)
        reset_skin_action = skin_menu.addAction("Cildi Sıfırla")
        reset_skin_action.triggered.connect(self.reset_skin)

        self.settings_menu.addSeparator()

        self.animation_menu = self.settings_menu.addMenu("Animasyonlar")
        
        # Animasyonların sadece biri seçilebilsin diye QActionGroup kullanmak en doğrusu.
        anim_group = QActionGroup(self)
        anim_group.setExclusive(True)

        anim_none = self.animation_menu.addAction("None")
        anim_none.setCheckable(True)
        anim_none.triggered.connect(lambda: self.set_animation("None"))
        anim_group.addAction(anim_none)

        anim_pulsar = self.animation_menu.addAction("Pulsar")
        anim_pulsar.setCheckable(True)
        anim_pulsar.triggered.connect(lambda: self.set_animation("Pulsar"))
        anim_group.addAction(anim_pulsar)

        self.anim_orbit = self.animation_menu.addAction("Yörünge") # Referansı sakla
        self.anim_orbit.setCheckable(True)
        self.anim_orbit.triggered.connect(lambda: self.set_animation("Yörünge"))
        anim_group.addAction(self.anim_orbit)

        anim_sparkle = self.animation_menu.addAction("Işıldama")
        anim_sparkle.setCheckable(True)
        anim_sparkle.triggered.connect(lambda: self.set_animation("Işıldama"))
        anim_group.addAction(anim_sparkle)

        # Başlangıçta doğru animasyonun seçili olduğundan emin ol
        for action in self.animation_menu.actions():
            action.setChecked(action.text() == self.animation_type)
        
        self.update_animation_menu_state()

        self.settings_menu.addSeparator()

        exit_action = self.settings_menu.addAction("BlackHole'u Kapat")
        exit_action.triggered.connect(QApplication.instance().quit)

    def update_animation_menu_state(self):
        """Animasyon menüsündeki 'Yörünge' seçeneğini moda göre etkinleştirir/devre dışı bırakır."""
        if hasattr(self, 'anim_orbit'):
            self.anim_orbit.setEnabled(self.mode == "storage")

    def set_mode(self, mode):
        """Uygulama modunu ayarlar ('storage' veya 'destroyer')."""
        self.mode = mode
        # Eğer Yok Edici moduna geçildiyse ve Yörünge animasyonu aktifse, animasyonu kapat.
        if self.mode == "destroyer" and self.animation_type == "Yörünge":
            self.set_animation("None")
        
        # Menüdeki Yörünge seçeneğinin etkinliğini güncelle
        self.update_animation_menu_state()

        self.update() # Rengin anında değişmesi için

    def set_base_radius(self, value):
        """Slider'dan gelen değere göre temel yarıçapı ayarlar."""
        self.base_radius = value
        if not self.expanded:
            self._radius = self.base_radius
            self.update()

    def open_color_picker(self):
        # Mevcut moda göre başlangıç rengini belirle
        initial_color = self.destroyer_color if self.mode == "destroyer" else self.storage_color
        color = QColorDialog.getColor(initial_color, self, "Kara Delik Rengini Seç", QColorDialog.ShowAlphaChannel)
        
        if color.isValid():
            # Rengi sadece aktif olan mod için değiştir
            if self.mode == "destroyer":
                self.destroyer_color = color
            else:
                self.storage_color = color
            self.skin_pixmap = None # Renk seçildiğinde cildi devre dışı bırak (her iki mod için de geçerli)
            self.skin_path = None   # Cilt yolunu da temizle
            self.update()

    def load_skin(self):
        file_name, _ = QFileDialog.getOpenFileName(self, "Cilt için Resim Seç", "", "Resim Dosyaları (*.png *.jpg *.jpeg *.bmp)")
        if file_name:
            pixmap = QPixmap(file_name) # Bu satır kalmalı
            if not pixmap.isNull():
                # QDialog'u doğrudan oluşturup çalıştırıyoruz.
                cropper_dialog = ImageCropper(pixmap, self)
                self.skin_path = file_name # Cilt dosyasının yolunu kaydetmek için sakla
                cropper_dialog.cropped.connect(self.set_cropped_skin)
                cropper_dialog.exec_()

    def reset_skin(self):
        self.skin_pixmap = None
        self.skin_path = None # Cilt yolunu da sıfırla
        self.update()


    def set_cropped_skin(self, pixmap):
        self.skin_pixmap = pixmap.scaled(QSize(400, 400), Qt.KeepAspectRatio, Qt.SmoothTransformation)
        # Cilt yüklendiğinde, ayarları kaydetmek için dosya yolunu sakla
        # self.skin_path zaten load_skin içinde ayarlandı.
        self.update()

    def set_animation(self, anim_type):
        self.animation_type = anim_type
        # QActionGroup seçimi otomatik olarak güncelleyecektir.
        if anim_type == "None":
            self.animation_timer.stop()
        else:
            self.animation_timer.start(16) # ~60 FPS için 16 ms'de bir güncelle
        self.update() # Değişikliğin anında yansıması için güncelle

    def update_animations(self):
        if self.animation_type == "Pulsar":
            # Yok edici modda animasyonları hızlandır
            speed_multiplier = 4.0 if self.mode == "destroyer" else 1.0

            center = self.rect().center()
            # Pulsar parçacıklarını oluştur
            if not self.pulsars or len(self.pulsars) != 25:
                self.pulsars = []
                for _ in range(25): # Daha az ama daha belirgin parçacık
                    r = random.uniform(20, self.radius - 20)
                    self.pulsars.append({
                        'angle': random.uniform(0, 2 * math.pi),
                        'radius': r,
                        'speed': random.uniform(0.01, 0.02), # Biraz daha hızlı
                        'size': random.uniform(2, 4) # Biraz daha büyük
                    })
            
            # Pulsar parçacıklarını hareket ettir
            for pulsar in self.pulsars:
                pulsar['angle'] += pulsar['speed']
                pulsar['radius'] -= 0.3 * speed_multiplier # Merkeze çekilme hızı

                if pulsar['radius'] < 10:
                    pulsar['radius'] = self.radius - 20
                    pulsar['angle'] = random.uniform(0, 2 * math.pi)

                pulsar['x'] = center.x() + pulsar['radius'] * math.cos(pulsar['angle'])
                pulsar['y'] = center.y() + pulsar['radius'] * math.sin(pulsar['angle'])
                # Sıfıra bölme hatasını önle
                denominator = self.radius - 20
                alpha = (pulsar['radius'] / denominator) * 255 if denominator > 0 else 0
                # Alpha değerinin 0-255 aralığında kalmasını garantile
                pulsar['alpha'] = max(0, min(255, alpha))

        elif self.animation_type == "Yörünge" and self.expanded:
            self.orbit_angle += 0.01

        elif self.animation_type == "Işıldama" and self.expanded:
            # Yok edici modda animasyonları hızlandır
            speed_multiplier = 4.0 if self.mode == "destroyer" else 1.0

            center = self.rect().center()
            # Başlangıçta ışıltıları oluştur veya sayıları eksikse tamamla
            if not self.sparkles or len(self.sparkles) != 40:
                self.sparkles = [] # Önce listeyi temizle
                for _ in range(40): # Işıltı sayısını artıralım
                    # Kutupsal koordinatları (açı, yarıçap) saklayalım
                    r = random.uniform(10, self.radius - 15)
                    self.sparkles.append({
                        'angle': random.uniform(0, 2 * math.pi),
                        'radius': r,
                        'speed': random.uniform(0.005, 0.015), # Dönüş hızı
                        'alpha': (r / (self.radius - 15)) * 255, # Dışarıdakiler daha parlak
                        'size': random.uniform(1, 2.5)
                    })
            
            # Mevcut ışıltıların pozisyonunu ve parlaklığını güncelle (Girdap efekti)
            for sparkle in self.sparkles:
                # Açıyı artırarak saat yönünde döndür
                sparkle['angle'] += sparkle['speed'] * speed_multiplier
                # Yarıçapı azaltarak merkeze doğru çek
                sparkle['radius'] -= 0.2 * speed_multiplier

                # Eğer merkezde kaybolduysa, dışarıda yeniden oluştur
                if sparkle['radius'] < 5:
                    sparkle['radius'] = self.radius - 15
                    sparkle['angle'] = random.uniform(0, 2 * math.pi)

                # Yeni pozisyonu ve parlaklığı hesapla
                sparkle['x'] = center.x() + sparkle['radius'] * math.cos(sparkle['angle'])
                sparkle['y'] = center.y() + sparkle['radius'] * math.sin(sparkle['angle'])
                # Sıfıra bölme hatasını önle
                denominator = self.radius - 15
                alpha = (sparkle['radius'] / denominator) * 200 if denominator > 0 else 0 # Merkeze yaklaştıkça sönsün
                # Alpha değerinin 0-255 aralığında kalmasını garantile
                sparkle['alpha'] = max(0, min(255, alpha))

        if self.animation_type != "None":
            self.update()

    def save_settings(self):
        """Uygulama ayarlarını bir JSON dosyasına kaydeder."""
        settings = {
            "storage_color": self.storage_color.name(QColor.HexArgb),
            "destroyer_color": self.destroyer_color.name(QColor.HexArgb),
            "animation": self.animation_type,
            "skin_path": self.skin_path, # Cilt dosya yolunu kaydet
            "base_radius": self.base_radius,
            "mode": self.mode
        }
        # Ayar dosyasını kullanıcı ana dizininde sakla
        config_path = os.path.join(os.path.expanduser("~"), ".blackhole_launcher_config.json")
        try:
            with open(config_path, 'w') as f:
                json.dump(settings, f, indent=4)
        except Exception as e:
            print(f"Ayarlar kaydedilemedi: {e}")

    def load_settings(self):
        """Uygulama ayarlarını JSON dosyasından yükler."""
        config_path = os.path.join(os.path.expanduser("~"), ".blackhole_launcher_config.json")
        if os.path.exists(config_path):
            try:
                with open(config_path, 'r') as f:
                    settings = json.load(f)
                
                # Dosyalar artık kaydedilmediği için, files listesini her zaman boş başlat
                self.files = [] 
                storage_color_name = settings.get("storage_color", "#14141eF0")
                self.storage_color = QColor(storage_color_name)

                destroyer_color_name = settings.get("destroyer_color", "#96141eF0") # Varsayılan kırmızı
                self.destroyer_color = QColor(destroyer_color_name)
                
                self.set_animation(settings.get("animation", "None"))

                skin_path = settings.get("skin_path")
                if skin_path and os.path.exists(skin_path):
                    self.skin_pixmap = QPixmap(skin_path).scaled(QSize(400, 400), Qt.KeepAspectRatio, Qt.SmoothTransformation)
                    self.skin_path = skin_path # Yolu sakla

                self.base_radius = settings.get("base_radius", 60)
                self._radius = self.base_radius

                self.mode = settings.get("mode", "storage")
                self.setGeometry(200, 200, 400, 400) # Yeniden boyutlandır

                self.update()
            except Exception as e:
                print(f"Ayarlar yüklenemedi: {e}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    ex = BlackHoleWidget()
    ex.show()
    app.exec_()

##Uygulama kapatıldığında dosya listesini, rengi ve cilt ayarını kaydedip tekrar açıldığında yüklemesini sağlayabilir misin?
##Dosya ikonlarını sürükleyerek yeniden sıralayabilme özelliği ekleyelim
##Dosyaları karadelik icine attıktan sonra uygulamayı kapatıyorum ve tekrar açtığımda dosyalar kayboluyor. Dosyaların kalıcı olarak saklanmasını sağlayabilir misin?
##metin yazıları bazen uzun metinler icin islevsiz kalıyor boyu yetmıyor
##ve hala dosyalar kayboluyor